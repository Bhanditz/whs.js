{"version":3,"sources":["meshes/Morph.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;IAAY,K;;AACZ;;;;AAEA;;AACA;;AACA;;;;;;IAEM,K;;;AACJ,mBAAyB;AAAA,QAAb,MAAa,yDAAJ,EAAI;AAAA;;AAAA,+GACjB,MADiB,EACT,OADS;;AAGvB,qBAAO,OAAO,QAAd,EAAwB;AACtB,YAAM;AADgB,KAAxB;;AAIA,UAAK,KAAL,CAAW,MAAX;AACA,kGAAW,MAAX;AARuB;AASxB;;;;4BAEkB;AAAA,UAAb,MAAa,yDAAJ,EAAI;;AACjB,UAAM,SAAS,IAAf;;AAEA,UAAM,UAAU,sBAAY,UAAC,OAAD,EAAa;AACvC,8BAAS,OAAO,QAAP,CAAgB,IAAzB,EAA+B,UAAC,IAAD,EAAO,SAAP,EAAqB;AAClD,cAAI,OAAO,QAAP,CAAgB,eAApB,EAAqC;AACnC,uBAAW,uBACT,iBAAO,OAAO,QAAd,EAAwB;AACtB,4BAAc,IADQ;AAEtB,4BAAc,MAAM;AAFE,aAAxB,CADS,EAKT,SALF;AAMD,WAPD,MAOO,IAAI,CAAC,SAAD,IAAc,OAAO,QAAP,CAAgB,iBAAlC,EAAqD;AAC1D,uBAAW,uBACT,OAAO,QADE,EAET,SAFF;AAGD,WAJM,MAIA,WAAW,IAAI,MAAM,aAAV,CAAwB,SAAxB,CAAX;;AAEP,eAAK,kBAAL;AACA,eAAK,oBAAL;;;AAGA,cAAM,OAAO,IAAI,MAAM,IAAV,CAAe,IAAf,EAAqB,QAArB,CAAb;AACA,eAAK,KAAL,GAAa,OAAO,KAAP,CAAa,KAA1B;AACA,eAAK,KAAL,GAAa,IAAI,MAAM,cAAV,CAAyB,IAAzB,CAAb;;AAEA,eAAK,KAAL,CACG,UADH,CACc,KAAK,UAAL,CAAgB,CAAhB,CADd,EAEG,WAFH,CAEe,OAAO,KAAP,CAAa,QAF5B,EAGG,IAHH;;AAKA,iBAAO,SAAP,CAAiB,IAAjB;;AAEA;AACD,SA9BD;AA+BD,OAhCe,CAAhB;;AAkCA,kGAAW,OAAX;;AAEA,aAAO,OAAP;AACD;;;4BAEO;AACN,aAAO,IAAI,KAAJ,CAAU,KAAK,SAAL,EAAV,EAA4B,KAAK,KAAjC,EAAwC,IAAxC,CAA6C,IAA7C,CAAP;AACD;;;;;QAID,K,GAAA,K","file":"Morph.js","sourcesContent":["import * as THREE from 'three';\nimport Physijs  from '../physics/physi.js';\n\nimport {Shape} from '../core/Shape';\nimport {extend, loadMaterial} from '../extras/api';\nimport {loadJson} from '../utils/loader';\n\nclass Morph extends Shape {\n  constructor(params = {}) {\n    super(params, 'morph');\n\n    extend(params.geometry, {\n      path: ''\n    });\n\n    this.build(params);\n    super.wrap('wait');\n  }\n\n  build(params = {}) {\n    const _scope = this;\n\n    const promise = new Promise((resolve) => {\n      loadJson(params.geometry.path, (data, materials) => {\n        if (params.material.useVertexColors) {\n          material = loadMaterial(\n            extend(params.material, {\n              morphTargets: true,\n              vertexColors: THREE.FaceColors\n            })\n          )._material;\n        } else if (!materials || params.material.useCustomMaterial) {\n          material = loadMaterial(\n            params.material\n          )._material;\n        } else material = new THREE.MultiMaterial(materials);\n\n        data.computeFaceNormals();\n        data.computeVertexNormals();\n\n        // Visualization.\n        const mesh = new THREE.Mesh(data, material);\n        mesh.speed = params.morph.speed;\n        mesh.mixer = new THREE.AnimationMixer(mesh);\n\n        mesh.mixer\n          .clipAction(data.animations[0])\n          .setDuration(params.morph.duration)\n          .play();\n\n        _scope.setNative(mesh);\n\n        resolve();\n      });\n    });\n\n    super.wait(promise);\n\n    return promise;\n  }\n\n  clone() {\n    return new Morph(this.getParams(), this._type).copy(this);\n  }\n}\n\nexport {\n  Morph\n};\n"]}